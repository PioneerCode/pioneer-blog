<!doctype html>
<html class="no-js" lang="">
<head>
  <link href="/app.css" rel="stylesheet" />
  <script src="/app.js"></script>
</head>
<body>
  <div class="row">
    <div class="large-10 large-push-1 columns">
      <h1>Deploying An ASP.NET Core Site, You're Still Doing It Wrong : Part 2 - TeamCity</h1>
      <article>
        <div class="note">
          <p>This day and age, predictability and reliability are two of the most important words when it comes deployments. In this series, I am going to talk about how to add both predictability and reliability to your ASP.NET Core Continuous Integration pipeline using TeamCity and Octopus Deploy.</p>
          <ol style="margin-bottom: 0;">
            <li>
              <a href="deploying-asp-net-core-teamcity-and-octopus-deploy-part-1" title="Deploying An ASP.NET Core Site With TeamCity And Octopus Deploy: You're Still Doing It Wrong">Intro</a>
            </li>
            <li>
              <a href="deploying-asp-net-core-teamcity-and-octopus-deploy-part-2" title="Deploying An ASP.NET Core Site, You're Still Doing It Wrong : Part 2 - TeamCity">TeamCity</a>
            </li>
            <li>
              <a href="deploying-asp-net-core-teamcity-and-octopus-deploy-part-3" title="Deploying An ASP.NET Core Site, You're Still Doing It Wrong : Part 3 - Octopus Deploy: Installation And Targets">Octopus Deploy: Installation And Targets</a>
            </li>
            <li>
              <a href="deploying-asp-net-core-teamcity-and-octopus-deploy-part-4" title="Deploying An ASP.NET Core Site, You're Still Doing It Wrong : Part 4 - Octopus Deploy: Configuration And Deployments">Octopus Deploy: Configuration And Deployments</a>
            </li>
            <li>
              <a href="deploying-asp-net-core-teamcity-and-octopus-deploy-part-5" title="Deploying An ASP.NET Core Site: You're Still Doing It Wrong - Part 5 - Why Stop Now">Why Stop Now</a>
            </li>
          </ol>
        </div>
        <p>In the previous post to this series, we talked about our desires to become more predictable and reliable through automation. We also touched on some of the prerequisites needed to accomplish this using the methods defined in this series. In this post, we will dive into creating the base of a Continuous Integration pipeline by setting up <a href="https://www.jetbrains.com/teamcity/" title="TeamCity" target="_blank">TeamCity</a> to serve our build server needs.</p>
        <h2>Wait, You Build Deployments Locally?</h2>
        <p>Building deployments out of your local source is for a lack of better words, a <b>terrible</b> idea. It is riddled with problems such as...</p>
        <ul>
          <li>
            Isolation
            <ul>
              <li>When building from x-number of environments, you are introducing x-number of variables that may or may not have an effect on the final build that is outputted.</li>
              <li>By Isolating the environment to a single point of entry (repository) and single point of exit (build server), you are removing the "it works on my machine" from the equation. </li>
            </ul>
          </li>
          <li>
            Traceable
            <ul>
              <li>When a build fails, we need to be able to trace its origination to determine what went wrong.</li>
              <li>If we are building from x-amount of entry points, we don't have a clear path to that origin.</li>
              <li>If we do not have a clear path to the origin, we don't have a clear definition of the state of the code and by way of cannot reliably say what caused any given issue.</li>
            </ul>
          </li>
          <li>
            Developer Alignment
            <ul>
              <li>If you are not using a single entry point for your build process, you are introducing the possibility of the state of code to not be aligned with the exceptions of multiple developers.</li>
              <li>
                For example, black-box developer A is working on feature B.  Black-box developer C is working on feature D and does not know about feature B.
                <ul>
                  <li>If developer C is responsible for producing a build for deployment, feature B might not end up in said deployment.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
        <p>To be honest, this list can go one for a very long time. A simple Google search will pull up an exhaustive list of reasons why build servers building from a single source of truth is the desired practice. Point being, if you are not doing such then you are definitely <b>still doing it wrong</b>.</p>
        <h2>Installation</h2>
        <p>TeamCity these day is super easy to install.  You have one of two option, install it using the <a href="https://www.jetbrains.com/teamcity/download/#section=windows" title="TeamCity Installer" target="_blank">TeamCity Installer</a> or do it like a modern developer would and use <a href="https://chocolatey.org/" title="Chocolatey" target="_blank">Chocolatey</a>.  I went the Chocolatey route and ran the following command.</p>
        <pre class="brush: bash">choco install teamcity</pre>
        <p>Once installed head over to <b>http://localhost:8111</b> and follow the prompts.</p>
        <p>Set the location where TeamCity will store its metadata on disk.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-1.jpg" title="TeamCity Directory" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-1.jpg" alt="TeamCity Directory" style="max-width: 805px; border: 1px solid #ccc;" />
        </a>
        <p>Make your connection to the database you want TeamCity to use.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-2.jpg" title="TeamCity Database" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-2.jpg" alt="TeamCity Database" style="max-width: 805px; border: 1px solid #ccc;" />
        </a>
        <p>It will take a minute or two to initialize the rest of TeamCity components but once it is done, you will be asked to accept a licensing agreement and create an administrator account. After you have finished creating an account, you will end up logged into the TeamCity portal.</p>
        <h2>Creating A Project</h2>
        <p>Now that we have our build server installed, it is time to create a project. A project is a group of one or more Build Configurations.  A Build Configuration is a set of steps that will automate the process of building an asset that we can use to deploy. Let's start with a blank project and configure everything manually. On the "Create Project" screen select "Manually" and fill out the required fields.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-6.png" title="TeamCity Create Project" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-6.png" alt="TeamCity Create Project" style="max-width: 895px; border: 1px solid #ccc;" />
        </a>
        <h2>Connecting Up With Our Source Code</h2>
        <p>Our build server needs to know or be told that our source code has changed in order to trigger a build. To accomplish this, we will have one of two options on how we want to communicate with Github.</p>
        <h3>Triggering From GitHub</h3>
        <p>If your install of TeamCity can be reached on the open Internet, you can set up GitHub to initiate a build every time code is pushed to your repository. To accomplish this you would create what is called a "Connection".  This connection will allow for GitHub to talk directly to TeamCity.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-4.jpg" title="TeamCity Create Connection" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-4.jpg" alt="TeamCity Create Connection" style="max-width: 870px; border: 1px solid #ccc;" />
        </a>
        <p>You will be required to register your instance of TeamCity with GitHub. Once register, you will be supplied with a "Client ID" and "Client secret" to finalize the contract between the two apps.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-5.jpg" title="TeamCity Polling" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-5.jpg" alt="TeamCity Polling" style="max-width: 764px; border: 1px solid #ccc;" />
        </a>
        <h3>Polling GitHub</h3>
        <p>If you don't want to open up access to your TeamCity instance from the Internet, you can instead tell TeamCity to poll your repository for changes. To accomplish this we will need to create two things.</p>
        <ol>
          <li>
            VCS root
            <ul>
              <li>Define how the project source code is actually retrieved from your repoisotry. </li>
            </ul>
          </li>
          <li>Trigger</li>
        </ol>
        <p>I will talk more about both of these topics after we create a Build Configuration.</p>
        <h2>Build Configuration</h2>
        <p>Now that our project is created and we have decided how we are going to tie in GitHub, we can start creating our Build Configuration.  Build Configurations are made up of the step by step process we want to automate in order to build our project.  For us, our goals will be as follows.</p>
        <ul>
          <li><b>Detect</b> changes to the source and pull it to our build server.</li>
          <li><b>Restore</b> all NuGet packages.</li>
          <li><b>Build</b> our project.</li>
          <li><b>Publish</b> the build and make it available to our automated deployment system, Octopus Deploy.</li>
        </ul>
        <p>Head over to your projects "General Settings" page and select "Create Build Configuration".  Let's again select the "Manually" option and fill out the required fields before hitting create.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-8.png" title="TeamCity Create Build Configuration" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-8.png" alt="TeamCity Create Build Configuration" style="max-width: 742px; border: 1px solid #ccc;" />
        </a>
        <h2>Version Number</h2>
        <p>Let's set up a versioning system for our build.  I am partial to <a href="http://semver.org/" title="Semantic Versioning" target="_blank">Semantic Versioning</a> so I will be basing it off that. In your Build Configuration, navigate to the "General Settings" page. Here you will want to enter <b>1.0.0.%build.counter%</b> in the "Build number format" field.  This establishes a semantic version number with a hanging auto-incrementing counter off the end.  It will be up to you to version forward the "semantic" portion of the version, but the "counter" will increment on ever build.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-13.png" title="TeamCity Versioning" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-13.png" alt="TeamCity Versioning" style="max-width: 1275px; border: 1px solid #ccc;" />
        </a>
        <h2>Detect</h2>
        <p class="note">If you setup GitHub to trigger you builds, you will not need to do this step.</p>
        <p>For our purposes, we are going to create a "VCS root" and "Trigger" to reach out to our repository and <b>detect</b> changes. In your Build Configuration, navigate to the "VCS Roots" page and hit "Create VCS root."  Fill out all required information including any branch targeting you would like to do. I am leaving mine so it polls the "master" branch.  I do this because I consider my "master" to be deployable at all time. Any important code only reaches my master branch when it has gone through a proper pull request.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-7.png" title="TeamCity Create VCS" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-7.png" alt="TeamCity Create VCS" style="max-width: 727px; border: 1px solid #ccc;" />
        </a>
        <p>Once the "VCS root" has been created, head over to your "Version Control Settings" and attach it to your Build Configuration.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-9.png" title="TeamCity Attach VCS Root" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-9.png" alt="TeamCity Attach VCS Root" style="max-width: 1145px; border: 1px solid #ccc;" />
        </a>
        <p>In the "Triggers" section, "Add New Trigger" and select the "VCS Trigger" type.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-10.png" title="TeamCity Add Trigger" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-10.png" alt="TeamCity Add Trigger" style="max-width: 1038px; border: 1px solid #ccc;" />
        </a>
        <p>The new "Trigger" will now add a build to the queue when a VCS check-in is detected.</p>
        <p>If you have not noticed yet, three of our four steps in regards to setting up our Build Configuration directly map to commands we run against the <b>dotnet cli</b>: restore, build and publish. Thankfully the team at Jet Brains has created a plugin to facilitate execution of these commands.</p>
        <h2>Installing "The" Plugin & .NET Core SDK</h2>
        <ul>
          <li>On the machine TeamCity is installed on, head over to the <a href="https://plugins.jetbrains.com/plugin/9190--net-core-support">TeamCity plugin gallery</a> and download the plugin.</li>
          <li>Copy the plugin zip package to your <b>\&lt;team city directory&gt;\plugins</b> directory.</li>
          <li>Restart your TeamCity service(s)</li>
          <li>
            Install the latest .NET Core SDK.  You have one of two options...
            <ul>
              <li>Head to <a href="https://www.microsoft.com/net/core#windowsvs2017"> the official download site</a> and get the installer from there.</li>
              <li>
                Or, do it like a modern dev and run the following chocolatey command.
                <pre class="brush: bash">choco install dotnetcore-sdk -y</pre>
              </li>
            </ul>
          </li>
        </ul>
        <h2>Build Configuration Steps</h2>
        <p>Now that we have the necessary plugin and SDK installed, we can create our individual build steps.</p>
        <h3>Restore</h3>
        <p>Head to your Build Configuration and under "Build Steps", select "Add Build Step". You will be given a choice of "Runner Type(s)".  Select the ".NET Core (dotnet)" runner that we just installed with the plugin.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-11.png" title="TeamCity Add Step" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-11.png" alt="TeamCity Add Step" style="max-width: 869px; border: 1px solid #ccc;" />
        </a>
        <p>You will be presented with a list of configuration options.  The values of which will be determined by your goals.  For my setup I added a "Step Name", changed the "Command" to "restore" and targeted my solution file in the "Projects" section.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-12.png" title="TeamCity Config Restore" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-12.png" alt="TeamCity Config Restore" style="max-width: 812px; border: 1px solid #ccc;" />
        </a>
        <h3>Build</h3>
        <p class="note">Technically this step is not needed if all your interested in doing is creating a build.  The next step will actually accomplish that for you.  That being said, this step is needed if you plan on introducing things like Unit Testing into your build pipeline.  With that in mind, best we just set it up now.  After all, Unit Tests are great!</p>
        <p>Again, head to the "Build Steps" and select "Add Build Step".  This time we will configure it with the same "Runner Type" but switch the command to "build". We will also set the "Configuration" which to build under to "Release".</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-14.png" title="TeamCity Config Build" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-14.png" alt="TeamCity Config Build" style="max-width: 804px; border: 1px solid #ccc;" />
        </a>
        <h3>Publish</h3>
        <p>The last step in the process is to tell the <b>dotnet cli</b> to "publish" our build to the file system.  Just like we did previously, we again "Add Build Step" and configure it to the same "Runner Type".  This time we switch the "command" to publish and set the "Configuration" which to build under to "Release".</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-15.png" title="TeamCity Config Publish" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-15.png" alt="TeamCity Config Publish" style="max-width: 804px; border: 1px solid #ccc;" />
        </a>
        <h2>Assets</h2>
        <p>Now that we have setup our build steps and the <b>dotnet cli</b> is in theory publishing assets to the file system, we need a way to tell TeamCity to take the published assets and make them available as an asset inside TeamCity. If we forgo this step, we will not have assets that we can access at the end of our build pipeline.  That being said, lets head to the "General Settings" section of our Build Configuration and add <b>publish => your.name.%build.number%</b> to the "Artifact paths" value.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-16.png" title="TeamCity Artifacts" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-16.png" alt="TeamCity Artifacts" style="max-width: 804px; border: 1px solid #ccc;" />
        </a>
        <p>By doing this, we should now be able to access the assets from our build portal.</p>
        <h2>Off We Go</h2>
        <p>Setup of TeamCity and its necessary configuration should be complete at this point.  Go ahead and check some code into your "master branch" on GitHub, watch your TeamCity portal to see the Build Agent recognize the change and then view your assets when your Build completes successfully. If all went well, you should end up with something like this.</p>
        <a href="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-17.png" title="TeamCity Success" target="_blank">
          <img src="/images/deploying-asp-net-core-teamcity-and-octopus-deploy/team-17.png" alt="TeamCity Success" style="max-width: 640px; border: 1px solid #ccc;" />
        </a>
        <h2>Up Next</h2>
        <p>And there you have it.  We just went from a non-automated build that was not traceable, to a fully automated build that is properly versioned making it traceable and more important predictable. Next up we will start tackling the automation of configuration and deployment by installing and configuring Octopus Deploy. Until then, feel free to leave any comments below.</p>
        <a href="deploying-asp-net-core-teamcity-and-octopus-deploy-part-3">Deploying An ASP.NET Core Site, You're Still Doing It Wrong : Part 3 - Octopus Deploy: Installation And Targets</a>
        <br />
        <br />
      </article>
    </div>
  </div>
</body>
</html>